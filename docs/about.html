<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>About – An Introduction to Statistical Learning</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./favicon.ico" rel="icon">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-d166b450ba5a8e9f7a0ab969bf6592c1.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-02131402185803fffdb13c72ead8d5c1.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-8072ba3c8f90baa049cfdfc6dfb138ec.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="site_libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.js"></script>
<link href="site_libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>

      .quarto-title-block .quarto-title-banner {
        background-image: url(images/banner_black_3.jpg);
background-size: cover;
      }
</style>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">An Introduction to Statistical Learning</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./about.html" aria-current="page"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="./index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">About</h1>
                      </div>
  </div>
  <div class="quarto-title-meta">
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">Monday, January 27, 2025</p>
      </div>
    </div>
    </div>
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<div class="quarto-about-jolla">
  <img src="images/tiling.png" class="about-image
  round " style="height: 15em; width: 15em;">
 <main class="content quarto-banner-title-block" id="quarto-document-content">
<p>This are some notes on one of my favorite books of all times: <em>An Introduction to Statistical Learning</em> by Gareth James, Daniela Witten, Trevor Hastie and Robert Tibshirani. And in this note perhaps I can explain why I like it so much, despite much criticism that are scattered throughout the notes.</p>
<p>The book is available for free from the authors’ website. The book is a great introduction to statistical learning and is a good starting point for anyone interested in machine learning. The book is a bit light on the maths but it is a good introduction to the concepts and the authors have a more advanced book called <em>The Elements of Statistical Learning</em> which is more mathematically rigorous.</p>
<p>Another reason I like this book is that there are videos by the authors on YouTube which explain the material. Although I first read the book book before the videos came out and I considered it easy to understand for most topics. However I found that the videos seem to be a bit orthogonal i.e.&nbsp;the seem to give lost of background information, beyond what is going on in the book. This is a good thing as it gives a lot of context to the material.</p>
<p>The authors also make their slides and figures available for free.</p>
<p>A little while back this book came out with codes in python. This makes it more relevant for data scientists and machine learning engineers then the original which came out in R. More so there is now a chapter on deep learning which is a big plus. Though I dare say its hard to get the lab to run properly on a local machine.</p>
<p>Tne book covers lots of algorithms as well as many practical aspects of Data Science and Machine Learning. The book is a great starting point for anyone interested in the field.</p>
<p>I haven’t come across any videos with some of the people who were not the authors of the course. I hope to find these.</p>
<p>1 Introduction 1</p>
<p>2 Statistical Learning 15 2.1 What Is Statistical Learning? . . . . . . . . . . . . . . . . . 15 2.1.1 Why Estimate f ? . . . . . . . . . . . . . . . . . . . 17 2.1.2 How Do We Estimate f ? . . . . . . . . . . . . . . . 20 2.1.3 The Trade-Off Between Prediction Accuracy and Model Interpretability . 23 2.1.4 Supervised Versus Unsupervised Learning . . . . . 25 2.1.5 Regression Versus Classification Problems . . . . . 27 2.2 Assessing Model Accuracy . . . . . . . . . . . . . . . . . . 27 2.2.1 Measuring the Quality of Fit . . . . . . . . . . . . 28 2.2.2 The Bias-Variance Trade-Off . . . . . . . . . . . . . 31 2.2.3 The Classification Setting . . . . . . . . . . . . . . 34 2.3 Lab: Introduction to Python . . . . . . . . . . . . . . . . . 40 2.3.1 Getting Started . . . . . . . . . . . . . . . . . . . . 40 2.3.2 Basic Commands . . . . . . . . . . . . . . . . . . . 40 2.3.3 Introduction to Numerical Python . . . . . . . . . 42 2.3.4 Graphics . . . . . . . . . . . . . . . . . . . . . . . . 48 2.3.5 Sequences and Slice Notation . . . . . . . . . . . . 51 2.3.6 Indexing Data . . . . . . . . . . . . . . . . . . . . . 51 2.3.7 Loading Data . . . . . . . . . . . . . . . . . . . . . 55 2.3.8 For Loops . . . . . . . . . . . . . . . . . . . . . . . 59 2.3.9 Additional Graphical and Numerical Summaries . . 61 2.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63</p>
<p>3 Linear Regression 69 3.1 Simple Linear Regression . . . . . . . . . . . . . . . . . . . 70 3.1.1 Estimating the Coefficients . . . . . . . . . . . . . 71 3.1.2 Assessing the Accuracy of the Coefficient Estimates . . . 72 3.1.3 Assessing the Accuracy of the Model . . . . . . . . 77 3.2 Multiple Linear Regression . . . . . . . . . . . . . . . . . . 80 3.2.1 Estimating the Regression Coefficients . . . . . . . 81 3.2.2 Some Important Questions . . . . . . . . . . . . . . 83 3.3 Other Considerations in the Regression Model . . . . . . . 91 3.3.1 Qualitative Predictors . . . . . . . . . . . . . . . . 91 3.3.2 Extensions of the Linear Model . . . . . . . . . . . 94 3.3.3 Potential Problems . . . . . . . . . . . . . . . . . . 100 3.4 The Marketing Plan . . . . . . . . . . . . . . . . . . . . . . 109 3.5 Comparison of Linear Regression with K-Nearest Neighbors . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111 3.6 Lab: Linear Regression . . . . . . . . . . . . . . . . . . . . 116 3.6.1 Importing packages . . . . . . . . . . . . . . . . . . 116 3.6.2 Simple Linear Regression . . . . . . . . . . . . . . . 117 3.6.3 Multiple Linear Regression . . . . . . . . . . . . . . 122 3.6.4 Multivariate Goodness of Fit . . . . . . . . . . . . 123 3.6.5 Interaction Terms . . . . . . . . . . . . . . . . . . . 124 3.6.6 Non-linear Transformations of the Predictors . . . 125 3.6.7 Qualitative Predictors . . . . . . . . . . . . . . . . 126 3.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127</p>
<p>4 Classification 135 4.1 An Overview of Classification . . . . . . . . . . . . . . . . . 135 4.2 Why Not Linear Regression? . . . . . . . . . . . . . . . . . 136 4.3 Logistic Regression . . . . . . . . . . . . . . . . . . . . . . 138 4.3.1 The Logistic Model . . . . . . . . . . . . . . . . . . 139 4.3.2 Estimating the Regression Coefficients . . . . . . . 140 4.3.3 Making Predictions . . . . . . . . . . . . . . . . . . 141 4.3.4 Multiple Logistic Regression . . . . . . . . . . . . . 142 4.3.5 Multinomial Logistic Regression . . . . . . . . . . . 144 4.4 Generative Models for Classification . . . . . . . . . . . . . 146 4.4.1 Linear Discriminant Analysis for p = 1 . . . . . . . 147 4.4.2 Linear Discriminant Analysis for p &gt; 1 . . . . . . . 150 4.4.3 Quadratic Discriminant Analysis . . . . . . . . . . 156 4.4.4 Naive Bayes . . . . . . . . . . . . . . . . . . . . . . 158 4.5 A Comparison of Classification Methods . . . . . . . . . . 161 4.5.1 An Analytical Comparison . . . . . . . . . . . . . . 161 4.5.2 An Empirical Comparison . . . . . . . . . . . . . . 164 4.6 Generalized Linear Models . . . . . . . . . . . . . . . . . . 167 4.6.1 Linear Regression on the Bikeshare Data . . . . . . 167 4.6.2 Poisson Regression on the Bikeshare Data . . . . . 169 4.6.3 Generalized Linear Models in Greater Generality . 172 4.7 Lab: Logistic Regression, LDA, QDA, and KNN . . . . . . 173 4.7.1 The Stock Market Data . . . . . . . . . . . . . . . 173 4.7.2 Logistic Regression . . . . . . . . . . . . . . . . . . 174 4.7.3 Linear Discriminant Analysis . . . . . . . . . . . . 179 4.7.4 Quadratic Discriminant Analysis . . . . . . . . . . 181 4.7.5 Naive Bayes . . . . . . . . . . . . . . . . . . . . . . 182 4.7.6 K-Nearest Neighbors . . . . . . . . . . . . . . . . . 183 4.7.7 Linear and Poisson Regression on the Bikeshare Data188 4.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193</p>
<p>5 Resampling Methods 201 5.1 Cross-Validation . . . . . . . . . . . . . . . . . . . . . . . . 202 5.1.1 The Validation Set Approach . . . . . . . . . . . . 202 5.1.2 Leave-One-Out Cross-Validation . . . . . . . . . . 204 5.1.3 k-Fold Cross-Validation . . . . . . . . . . . . . . . 206 5.1.4 Bias-Variance Trade-Off for k-Fold Cross-Validation . . . . . . . . . . . . . . . . . . . 208 5.1.5 Cross-Validation on Classification Problems . . . . 209 5.2 The Bootstrap . . . . . . . . . . . . . . . . . . . . . . . . . 212 5.3 Lab: Cross-Validation and the Bootstrap . . . . . . . . . . 215 5.3.1 The Validation Set Approach . . . . . . . . . . . . 216 5.3.2 Cross-Validation . . . . . . . . . . . . . . . . . . . 217 5.3.3 The Bootstrap . . . . . . . . . . . . . . . . . . . . 220 5.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224</p>
<p>6 Linear Model Selection and Regularization 229 6.1 Subset Selection . . . . . . . . . . . . . . . . . . . . . . . . 231 6.1.1 Best Subset Selection . . . . . . . . . . . . . . . . . 231 6.1.2 Stepwise Selection . . . . . . . . . . . . . . . . . . 233 6.1.3 Choosing the Optimal Model . . . . . . . . . . . . 235 6.2 Shrinkage Methods . . . . . . . . . . . . . . . . . . . . . . 240 6.2.1 Ridge Regression . . . . . . . . . . . . . . . . . . . 240 6.2.2 The Lasso . . . . . . . . . . . . . . . . . . . . . . . 244 6.2.3 Selecting the Tuning Parameter . . . . . . . . . . . 252 6.3 Dimension Reduction Methods . . . . . . . . . . . . . . . . 253 6.3.1 Principal Components Regression . . . . . . . . . . 254 6.3.2 Partial Least Squares . . . . . . . . . . . . . . . . . 260 6.4 Considerations in High Dimensions . . . . . . . . . . . . . 262 6.4.1 High-Dimensional Data . . . . . . . . . . . . . . . . 262 6.4.2 What Goes Wrong in High Dimensions? . . . . . . 263 6.4.3 Regression in High Dimensions . . . . . . . . . . . 265 6.4.4 Interpreting Results in High Dimensions . . . . . . 266 6.5 Lab: Linear Models and Regularization Methods . . . . . . 267 6.5.1 Subset Selection Methods . . . . . . . . . . . . . . 268 6.5.2 Ridge Regression and the Lasso . . . . . . . . . . . 273 6.5.3 PCR and PLS Regression . . . . . . . . . . . . . . 280 6.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283</p>
<p>7 Moving Beyond Linearity 289 7.1 Polynomial Regression . . . . . . . . . . . . . . . . . . . . . 290 7.2 Step Functions . . . . . . . . . . . . . . . . . . . . . . . . . 292 7.3 Basis Functions . . . . . . . . . . . . . . . . . . . . . . . . 293 7.4 Regression Splines . . . . . . . . . . . . . . . . . . . . . . . 294 7.4.1 Piecewise Polynomials . . . . . . . . . . . . . . . . 294 7.4.2 Constraints and Splines . . . . . . . . . . . . . . . 296 7.4.3 The Spline Basis Representation . . . . . . . . . . 296 7.4.4 Choosing the Number and Locations of the Knots . . . . . . 297 7.4.5 Comparison to Polynomial Regression . . . . . . . 299 7.5 Smoothing Splines . . . . . . . . . . . . . . . . . . . . . . . 300 7.5.1 An Overview of Smoothing Splines . . . . . . . . . 300 7.5.2 Choosing the Smoothing Parameter λ. . . . . . . 301 7.6 Local Regression . . . . . . . . . . . . . . . . . . . . . . . . 303 7.7 Generalized Additive Models . . . . . . . . . . . . . . . . . 305 7.7.1 GAMs for Regression Problems . . . . . . . . . . . 306 7.7.2 GAMs for Classification Problems . . . . . . . . . . 308 7.8 Lab: Non-Linear Modeling . . . . . . . . . . . . . . . . . . 309 7.8.1 Polynomial Regression and Step Functions . . . . . 310 7.8.2 Splines . . . . . . . . . . . . . . . . . . . . . . . . . 315 7.8.3 Smoothing Splines and GAMs . . . . . . . . . . . . 317 7.8.4 Local Regression . . . . . . . . . . . . . . . . . . . 324 7.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325</p>
<p>8 Tree-Based Methods 331 8.1 The Basics of Decision Trees . . . . . . . . . . . . . . . . . 331 8.1.1 Regression Trees . . . . . . . . . . . . . . . . . . . 331 8.1.2 Classification Trees . . . . . . . . . . . . . . . . . . 337 8.1.3 Trees Versus Linear Models . . . . . . . . . . . . . 341 8.1.4 Advantages and Disadvantages of Trees . . . . . . . 341 8.2 Bagging, Random Forests, Boosting, and Bayesian Additive Regression Trees . . 343 8.2.1 Bagging . . . . . . . . . . . . . . . . . . . . . . . . 343 8.2.2 Random Forests . . . . . . . . . . . . . . . . . . . . 346 8.2.3 Boosting . . . . . . . . . . . . . . . . . . . . . . . . 347 8.2.4 Bayesian Additive Regression Trees . . . . . . . . . 350 8.2.5 Summary of Tree Ensemble Methods . . . . . . . . 353 8.3 Lab: Tree-Based Methods . . . . . . . . . . . . . . . . . . . 354 8.3.1 Fitting Classification Trees . . . . . . . . . . . . . . 355 8.3.2 Fitting Regression Trees . . . . . . . . . . . . . . . 358 8.3.3 Bagging and Random Forests . . . . . . . . . . . . 360 8.3.4 Boosting . . . . . . . . . . . . . . . . . . . . . . . . 361 8.3.5 Bayesian Additive Regression Trees . . . . . . . . . 362 8.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 363</p>
<p>9 Support Vector Machines 367 9.1 Maximal Margin Classifier . . . . . . . . . . . . . . . . . . 367 9.1.1 What Is a Hyperplane? . . . . . . . . . . . . . . . . 368 9.1.2 Classification Using a Separating Hyperplane . . . 368 9.1.3 The Maximal Margin Classifier . . . . . . . . . . . 370 9.1.4 Construction of the Maximal Margin Classifier . . 372 9.1.5 The Non-separable Case . . . . . . . . . . . . . . . 372 9.2 Support Vector Classifiers . . . . . . . . . . . . . . . . . . . 373 9.2.1 Overview of the Support Vector Classifier . . . . . 373 9.2.2 Details of the Support Vector Classifier . . . . . . . 374 9.3 Support Vector Machines . . . . . . . . . . . . . . . . . . . 377 9.3.1 Classification with Non-Linear Decision Boundaries . . . 378 9.3.2 The Support Vector Machine . . . . . . . . . . . . 379 9.3.3 An Application to the Heart Disease Data . . . . . 382 9.4 SVMs with More than Two Classes . . . . . . . . . . . . . 383 9.4.1 One-Versus-One Classification . . . . . . . . . . . . 384 9.4.2 One-Versus-All Classification . . . . . . . . . . . . 384 9.5 Relationship to Logistic Regression . . . . . . . . . . . . . 384 9.6 Lab: Support Vector Machines . . . . . . . . . . . . . . . . 387 9.6.1 Support Vector Classifier . . . . . . . . . . . . . . . 387 9.6.2 Support Vector Machine . . . . . . . . . . . . . . . 390 9.6.3 ROC Curves . . . . . . . . . . . . . . . . . . . . . . 392 9.6.4 SVM with Multiple Classes . . . . . . . . . . . . . 393 9.6.5 Application to Gene Expression Data . . . . . . . . 394 9.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . 395</p>
<p>10 Deep Learning 399 10.1 Single Layer Neural Networks . . . . . . . . . . . . . . . . 400 10.2 Multilayer Neural Networks . . . . . . . . . . . . . . . . . . 402 10.3 Convolutional Neural Networks . . . . . . . . . . . . . . . . 406 10.3.1 Convolution Layers . . . . . . . . . . . . . . . . . . 407 10.3.2 Pooling Layers . . . . . . . . . . . . . . . . . . . . 410 10.3.3 Architecture of a Convolutional Neural Network . . 410 10.3.4 Data Augmentation . . . . . . . . . . . . . . . . . . 411 10.3.5 Results Using a Pretrained Classifier . . . . . . . . 412 10.4 Document Classification . . . . . . . . . . . . . . . . . . . . 413 10.5 Recurrent Neural Networks . . . . . . . . . . . . . . . . . . 416 10.5.1 Sequential Models for Document Classification . . 418 10.5.2 Time Series Forecasting . . . . . . . . . . . . . . . 420 10.5.3 Summary of RNNs . . . . . . . . . . . . . . . . . . 424 10.6 When to Use Deep Learning . . . . . . . . . . . . . . . . . 425 10.7 Fitting a Neural Network . . . . . . . . . . . . . . . . . . . 427 10.7.1 Backpropagation . . . . . . . . . . . . . . . . . . . 428 10.7.2 Regularization and Stochastic Gradient Descent . . 429 10.7.3 Dropout Learning . . . . . . . . . . . . . . . . . . . 431 10.7.4 Network Tuning . . . . . . . . . . . . . . . . . . . . 431 10.8 Interpolation and Double Descent . . . . . . . . . . . . . . 432 10.9 Lab: Deep Learning . . . . . . . . . . . . . . . . . . . . . . 435 10.9.1 Single Layer Network on Hitters Data . . . . . . . 437 10.9.2 Multilayer Network on the MNIST Digit Data . . . 444 10.9.3 Convolutional Neural Networks . . . . . . . . . . . 448 10.9.4 Using Pretrained CNN Models . . . . . . . . . . . 452 10.9.5 IMDB Document Classification . . . . . . . . . . . 454 10.9.6 Recurrent Neural Networks . . . . . . . . . . . . . 458 10.10 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465</p>
<p>11 Survival Analysis and Censored Data 469 11.1 Survival and Censoring Times . . . . . . . . . . . . . . . . 470 11.2 A Closer Look at Censoring . . . . . . . . . . . . . . . . . . 470 11.3 The Kaplan–Meier Survival Curve . . . . . . . . . . . . . . 472 11.4 The Log-Rank Test . . . . . . . . . . . . . . . . . . . . . . 474 11.5 Regression Models With a Survival Response . . . . . . . . 476 11.5.1 The Hazard Function . . . . . . . . . . . . . . . . . 476 11.5.2 Proportional Hazards . . . . . . . . . . . . . . . . . 478 11.5.3 Example: Brain Cancer Data . . . . . . . . . . . . 482 11.5.4 Example: Publication Data . . . . . . . . . . . . . 482 11.6 Shrinkage for the Cox Model . . . . . . . . . . . . . . . . . 484 11.7 Additional Topics . . . . . . . . . . . . . . . . . . . . . . . 486 11.7.1 Area Under the Curve for Survival Analysis . . . . 486 11.7.2 Choice of Time Scale . . . . . . . . . . . . . . . . . 487 11.7.3 Time-Dependent Covariates . . . . . . . . . . . . . 488 11.7.4 Checking the Proportional Hazards Assumption . . 488 11.7.5 Survival Trees . . . . . . . . . . . . . . . . . . . . . 488 11.8 Lab: Survival Analysis . . . . . . . . . . . . . . . . . . . . . 489 11.8.1 Brain Cancer Data . . . . . . . . . . . . . . . . . . 489 11.8.2 Publication Data . . . . . . . . . . . . . . . . . . . 493 11.8.3 Call Center Data . . . . . . . . . . . . . . . . . . . 494 11.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 498</p>
<p>12 Unsupervised Learning 503 12.1 The Challenge of Unsupervised Learning . . . . . . . . . . 503 12.2 Principal Components Analysis . . . . . . . . . . . . . . . . 504 12.2.1 What Are Principal Components? . . . . . . . . . . 505 12.2.2 Another Interpretation of Principal Components . 508 12.2.3 The Proportion of Variance Explained . . . . . . . 510 12.2.4 More on PCA . . . . . . . . . . . . . . . . . . . . . 512 12.2.5 Other Uses for Principal Components . . . . . . . . 515 12.3 Missing Values and Matrix Completion . . . . . . . . . . . 515 12.4 Clustering Methods . . . . . . . . . . . . . . . . . . . . . . 520 12.4.1 K-Means Clustering . . . . . . . . . . . . . . . . . 521 12.4.2 Hierarchical Clustering . . . . . . . . . . . . . . . . 525 12.4.3 Practical Issues in Clustering . . . . . . . . . . . . 532 12.5 Lab: Unsupervised Learning . . . . . . . . . . . . . . . . . 535 12.5.1 Principal Components Analysis . . . . . . . . . . . 535 12.5.2 Matrix Completion . . . . . . . . . . . . . . . . . . 539 12.5.3 Clustering . . . . . . . . . . . . . . . . . . . . . . . 542 12.5.4 NCI60 Data Example . . . . . . . . . . . . . . . . . 546 12.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . 552</p>
<p>13 Multiple Testing 557 13.1 A Quick Review of Hypothesis Testing . . . . . . . . . . . 558 13.1.1 Testing a Hypothesis . . . . . . . . . . . . . . . . . 558 13.1.2 Type I and Type II Errors . . . . . . . . . . . . . . 562 13.2 The Challenge of Multiple Testing . . . . . . . . . . . . . . 563 13.3 The Family-Wise Error Rate . . . . . . . . . . . . . . . . . 565 13.3.1 What is the Family-Wise Error Rate? . . . . . . . 565 13.3.2 Approaches to Control the Family-Wise Error Rate 567 13.3.3 Trade-Off Between the FWER and Power . . . . . 572 13.4 The False Discovery Rate . . . . . . . . . . . . . . . . . . . 573 13.4.1 Intuition for the False Discovery Rate . . . . . . . 573 13.4.2 The Benjamini–Hochberg Procedure . . . . . . . . 575 13.5 A Re-Sampling Approach to p-Values and False Discovery Rates . . . 577 13.5.1 A Re-Sampling Approach to the p-Value . . . . . . 578 13.5.2 A Re-Sampling Approach to the False Discovery Rate579 13.5.3 When Are Re-Sampling Approaches Useful? . . . . 581 13.6 Lab: Multiple Testing . . . . . . . . . . . . . . . . . . . . . 583 13.6.1 Review of Hypothesis Tests . . . . . . . . . . . . . 583 13.6.2 Family-Wise Error Rate . . . . . . . . . . . . . . . 585 13.6.3 False Discovery Rate . . . . . . . . . . . . . . . . . 588 13.6.4 A Re-Sampling Approach . . . . . . . . . . . . . . 590</p>


</main> 
  <hr class="about-sep">
   <div class="about-links">
  <a href="https://twitter.com" class="about-link" rel="" target="">
    <i class="bi bi-twitter"></i>
     <span class="about-link-text">Twitter</span>
  </a>
  <a href="https://linkedin.com" class="about-link" rel="" target="">
    <i class="bi bi-linkedin"></i>
     <span class="about-link-text">LinkedIn</span>
  </a>
  <a href="https://github.com" class="about-link" rel="" target="">
    <i class="bi bi-github"></i>
     <span class="about-link-text">Github</span>
  </a>
</div>
</div>
 <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/orenbochman\.github\.io\/notes-islr\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
          // default icon
          link.classList.add("external");
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
    <script type="text/javascript">
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let pseudocodeOptions = {
          indentSize: el.dataset.indentSize || "1.2em",
          commentDelimiter: el.dataset.commentDelimiter || "//",
          lineNumber: el.dataset.lineNumber === "true" ? true : false,
          lineNumberPunc: el.dataset.lineNumberPunc || ":",
          noEnd: el.dataset.noEnd === "true" ? true : false,
          titlePrefix: el.dataset.captionPrefix || "Algorithm"
        };
        pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
      });
    })(document);
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let captionSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
        if (captionSpan !== null) {
          let captionPrefix = el.dataset.captionPrefix + " ";
          let captionNumber = "";
          if (el.dataset.pseudocodeNumber) {
            captionNumber = el.dataset.pseudocodeNumber + " ";
            if (el.dataset.chapterLevel) {
              captionNumber = el.dataset.chapterLevel + "." + captionNumber;
            }
          }
          captionSpan.innerHTML = captionPrefix + captionNumber;
        }
      });
    })(document);
    </script>
  




</body></html>